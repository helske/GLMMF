{
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n#include \"ssglmInternals.h\"\n// via the depends attribute we tell Rcpp to create hooks for\n// RcppArmadillo so that the build process will know what to do\n//\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// simple example of creating two matrices and\n// returning the result of an operatioon on them\n//\n// via the exports attribute we tell Rcpp to make this function\n// available from R\n\ndouble filterFInternal(const arma::mat& y, const arma::cube& Z, const arma::mat& H,\nconst arma::vec& a1, const arma::mat& P1, const arma::mat& P1inf, const double tol, arma::mat& theta,\nconst arma::umat& zind, const int nfactors) {\n  \n  \n  \n  \n  double tiny = std::numeric_limits<double>::min();\n  \n  arma::mat at(a1.begin(),P1.n_rows);\n  arma::vec vt(Z.n_rows,Z.n_slices);\n      \n  arma::mat pt(P1.begin(),P1.n_rows,P1.n_rows);\n  arma::cube kt(P1.n_rows,Z.n_rows,Z.n_slices);\n  arma::vec ft(Z.n_rows,Z.n_slices);\n  arma::vec rt(P1.n_rows);\n  \n  arma::mat pinf(P1.begin(),P1.n_rows,P1.n_rows);\n  arma::cube kinf(P1.n_rows,Z.n_rows,Z.n_slices);  \n  arma::vec finf(Z.n_rows,Z.n_slices);\n  arma::vec rtinf(P1.n_rows);\n  \n  arma::mat alphaf(nfactors,Z.n_slices);\n  \n  unsigned int m1 = Z.n_rows;  \n\n  unsigned int j=0;\n  unsigned int d=0;\n  int rankp = arma::accu(P1inf);\n  \n  double lik = 0.0;\n  const double c = 0.5*std::log(2.0*M_PI);\n  \n  double finv;\n  \n  kt.slice(0).col(0) = pt.slice(0).cols(zind.col(0))*Z.slice(0).col(0);    \n  double yhat = arma::accu(Z.slice(0).col(0)%at.rows(zind.col(0)));\n  double zk = arma::accu(Z.slice(0).col(0)%kt.slice(0).col(0).rows(zind.col(0)));  \n  \n  if(rankp>0){\n    \n    kinf.slice(0).col(0) = pinf.slice(0).cols(zind.col(0))*Z.slice(0).col(0);   \n    finf(0,0) = arma::accu(Z.slice(0).col(0)%kinf.slice(0).col(0).rows(zind.col(0)));  \n    while(d < Z.n_slices && rankp>0){   \n      \n      for(j=0; j<Z.n_cols; j++){\n        if(arma::is_finite(y(d,j))){\n          ft(j,d) = zk + H(d,j);\n          if(finf(j,d)>tol){\n            finv = 1.0/finf(j,d);\n            lik += 0.5*log(finv);\n            vt(j,d) = y(d,j)-yhat;\n            at = at + kinf.slice(d).col(j)*vt(j,d)*finv;             \n            //pinf = pinf - kinf*kinf.t()*finf;\n            //pt = pt +(kinf*kinf.t()*ft*finf-kt*kinf.t()-kinf*kt.t())*finf; \n            for(unsigned int k = 0; k<pinf.n_rows; k++){\n              for(unsigned int l = k; l<pinf.n_rows; l++){                \n                pinf(l,k,d) = pinf(l,k,d) - kinf(l,j,d)*kinf(k,j,d)*finv; \n                pt(l,k,d) = pt(l,k,d) +kinf(l,j,d)*kinf(k,j,d)*pow(finv,2)*ft(j,d)-\n                kt(l,j,d)*kinf(k,j,d)*finv-kinf(l,j,d)*kt(k,j,d)*finv;\n              }\n            }\n            //pt = symmatl(pt);\n            //pinf = symmatl(pinf);  \n            \n            rankp--;\n          } else {\n            if (ft(j,d) > tiny){\n              finv=1.0/ft(j,d);\n              vt(j,d) = y(d,j)-yhat;\n              lik -= c + 0.5*(-log(finv) + pow(vt(j,d),2)*finv);\n              at = at + kt.slice(d).col(j)*vt(j,d)*finv;\n              //pt = pt - kt*kt.t()*ft; \n              for(unsigned int k = 0; k<pt.n_rows; k++){\n                for(unsigned int l = k; l<pt.n_rows; l++){\n                  pt(l,k,d) = pt(l,k,d) - kt(l,j,d)*kt(k,j,d)*finv;         \n                }\n              }\n              //pt = symmatl(pt); \n            }\n          }\n        }\n\n        if(j==(Z.n_cols-1)){\n          //next time step\n          if(d<(Z.n_slices-1)){               \n                        \n              pt.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n              pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n              pt.submat(0,0,nfactors-1,nfactors-1).eye();\n              pinf.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n              pinf.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n              pinf.submat(0,0,nfactors-1,nfactors-1).eye();\n              at.subvec(0,nfactors-1).zeros();\n              //Rcpp::Rcout<<atf.col(d)<<std::endl; //upper triangular part is not referenced!!\n              //Rcpp::Rcout<<pt<<std::endl;\n            \n            //kt =     pt.cols(zind.col(0))*Z.slice(d+1).col(0);   \n            //kinf = pinf.cols(zind.col(0))*Z.slice(d+1).col(0);\n            kt.zeros();\n            for(unsigned int k = 0; k<pt.n_rows; k++){\n              for(unsigned int l = 0; l<m1; l++){\n                kt(k) = kt(k) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n              }\n            }  \n            kinf.zeros();\n            for(unsigned int k = 0; k<pt.n_rows; k++){\n              for(unsigned int l = 0; l<m1; l++){\n                kinf(k) = kinf(k) + pinf(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n              }\n            }  \n            yhat = arma::accu(Z.slice(d+1).col(0)%at.rows(zind.col(0)));\n            zk = arma::accu(Z.slice(d+1).col(0)%kt.rows(zind.col(0)));          \n            finf = arma::accu(Z.slice(d+1).col(0)%kinf.rows(zind.col(0)));  \n          }\n        } else {\n          //next observation\n          //kt =  pt.cols(zind.col(j+1))*Z.slice(d).col(j+1);\n          //kinf = pinf.cols(zind.col(j+1))*Z.slice(d).col(j+1);\n          kt.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k) = kt(k) + pt(std::max(k,zind(l,j+1)), std::min(k,zind(l,j+1))) * Z(l,j+1,d);       \n            }\n          }\n          kinf.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kinf(k) = kinf(k) + pinf(std::max(k,zind(l,j+1)), std::min(k,zind(l,j+1))) * Z(l,j+1,d);       \n            }\n          }\n          yhat = arma::accu(Z.slice(d).col(j+1)%at.rows(zind.col(j+1)));\n          zk = arma::accu(Z.slice(d).col(j+1)%kt.rows(zind.col(j+1))); \n          finf = arma::accu(Z.slice(d).col(j+1)%kinf.rows(zind.col(j+1)));\n          \n        }\n        if(rankp==0){\n          d--; // negate the last increment below \n          break;\n        }\n        \n      }\n      d++;\n    }\n    \n    for(unsigned int i = j+1; i<Z.n_cols; i++){\n      \n      if(arma::is_finite(y(d,i))){\n        ft = zk + H(d,i);\n        \n        if (ft > tiny){\n          ft = 1.0/ft;\n          vt = y(d,i)-yhat;\n          lik -= c + 0.5*(-log(ft) + pow(vt,2)*ft);\n          at = at + kt*vt*ft;\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = k; l<pt.n_rows; l++){\n              pt(l,k) = pt(l,k) - kt(l)*kt(k)*ft;          \n            }\n          }\n          //pt = symmatl(pt);         \n        }\n      }\n      if(i==(Z.n_cols-1)){\n        //next time step\n        if(d<(Z.n_slices-1)){\n          \n           \n            pt.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n            pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n            pt.submat(0,0,nfactors-1,nfactors-1).eye();\n            at.subvec(0,nfactors-1).zeros();\n          \n          //kt = pt.cols(zind.col(0))*Z.slice(d+1).col(0);     \n          kt.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k) = kt(k) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n            }\n          }   \n          yhat = arma::accu(Z.slice(d+1).col(0)%at.rows(zind.col(0)));\n          zk = arma::accu(Z.slice(d+1).col(0)%kt.rows(zind.col(0)));         \n        }\n      } else {\n        //next observation\n        // kt = pt.cols(zind.col(i+1))*Z.slice(d).col(i+1);      \n        kt.zeros();\n        for(unsigned int k = 0; k<pt.n_rows; k++){\n          for(unsigned int l = 0; l<m1; l++){\n            kt(k) = kt(k) + pt(std::max(k,zind(l,i+1)), std::min(k,zind(l,i+1))) * Z(l,i+1,d);       \n          }\n        }\n        yhat = arma::accu(Z.slice(d).col(i+1)%at.rows(zind.col(i+1)));\n        zk = arma::accu(Z.slice(d).col(i+1)%kt.rows(zind.col(i+1))); \n        \n      }\n      \n      \n    }\n    d++;\n  }    \n  \n  \n \n  for(unsigned int t = d; t<Z.n_slices; t++){   \n    for(unsigned int i = 0; i<Z.n_cols; i++){\n      if(arma::is_finite(y(t,i))){\n        ft = zk + H(t,i);\n        \n        if (ft > tiny){\n          ft = 1.0/ft;\n          vt = y(t,i)-yhat;\n          lik -= c + 0.5*(-log(ft) + pow(vt,2)*ft);\n          at = at + kt*vt*ft;\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = k; l<pt.n_rows; l++){\n              pt(l,k) = pt(l,k) - kt(l)*kt(k)*ft;          \n            }\n          }         \n        }\n      }\n      \n      if(i==(Z.n_cols-1)){\n        //next time step\n        if(t<(Z.n_slices-1)){  \n          \n            \n            pt.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n            pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n            pt.submat(0,0,nfactors-1,nfactors-1).eye();\n            at.subvec(0,nfactors-1).zeros();\n          \n          kt.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k) = kt(k) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,t+1);       \n            }\n          }        \n          yhat = arma::accu(Z.slice(t+1).col(0)%at.rows(zind.col(0)));\n          zk = arma::accu(Z.slice(t+1).col(0)%kt.rows(zind.col(0)));         \n        }\n      } else {\n        //next observation      \n        kt.zeros();\n        for(unsigned int k = 0; k<pt.n_rows; k++){\n          for(unsigned int l = 0; l<m1; l++){\n            kt(k) = kt(k) + pt(std::max(k,zind(l,i+1)), std::min(k,zind(l,i+1))) * Z(l,i+1,t);       \n          }\n        }  \n        yhat = arma::accu(Z.slice(t).col(i+1)%at.rows(zind.col(i+1)));\n        zk = arma::accu(Z.slice(t).col(i+1)%kt.rows(zind.col(i+1))); \n        \n      }        \n      \n    } \n  }\n  \n  \n  return lik;\n}",
    "created" : 1413969636802.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3273839659",
    "id" : "B2F8CA39",
    "lastKnownWriteTime" : 1413975088,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/src/filterFInternal.cpp",
    "project_path" : "src/filterFInternal.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}