{
    "contents" : "fitGLMMF2<-function(model,estimate.dispersion,correlating.effects,maxiter,maxiter2, convtol,\n                   init.random.cov,init.dispersion,init.factor,init.theta=NULL,common.dispersion,estimate,trace,\n                   gradient=TRUE,maxapp=10,epsilon=1e-5,...){\n  \n  \n  #for more compact likfn  \n  nr<-model$nrandom\n  nf<-model$nfactors\n  nc<-model$ncommon\n  nd<-model$ndistinct\n  n<-nrow(model$y)\n  p<-ncol(model$y)\n  m<-nrow(model$P1)\n  if(!is.null(init.theta) && !identical(dim(init.theta),c(n,p))){    \n    stop(\"init.theta is not of valid form.\")       \n  } \n  \n  if(missing(estimate.dispersion) || estimate.dispersion){\n    if(model$distribution%in%c(\"gaussian\",\"negative binomial\",\"gamma\")){\n      ndisp<-ifelse(common.dispersion,1,p)\n    } else ndisp<-0\n  } else ndisp<-0\n  \n  if(nr<2) correlating.effects<-FALSE\n  \n  if(nf>0){\n    if(missing(init.factor)){\n      init.factors<-rep(1,p*nf-sum(upper.tri(diag(nf))))\n    } else {\n      if(!identical(dim(init.factor),c(p,as.integer(nf)))){\n        stop(\"Dimensions of the initial latent factor matrix is not equal to p*nfactors.\")\n      }\n      init.factors<-init.factor[lower.tri(init.factor,TRUE)]\n    }  \n  } else init.factors<-NULL\n  \n  if(ndisp>0){\n    if(missing(init.dispersion)){\n      init.dispersion<-rep(1,ndisp)\n    } else {\n      if(length(init.dispersion)==1){\n        init.dispersion<-rep(log(init.dispersion),ndisp)\n      } else {\n        if(length(init.dispersion)!=ndisp) \n          stop(\"Number of initial values for distinct dispersion parameters is not equal to groups\")\n        init.dispersion<-log(init.dispersion)\n      }\n    }  \n  }\n  \n  if(nr>0){\n    if(missing(init.random.cov)){\n      if(correlating.effects){ \n        init.random <- diag(nr)[upper.tri(diag(nr),TRUE)] \n      }else{ \n        init.random <- rep(1, nr)\n      }\n    }else {\n      if(!identical(dim(init.random.cov),c(nr,nr)))\n        stop(\"Dimensions of the initial covariance matrix of random effects does not match with number of random effects.\")\n      \n      if(correlating.effects){\n        init.random.cov<-VarCorr(fm1)$Subject\n        tmp<-chol(init.random.cov)\n        init.random<-c(2*log(diag(tmp)),tmp[upper.tri(tmp)])  \n      } else init.random<-sqrt(init.random.cov[1 + 0:(nr - 1) * (nr + 1)])\n    }\n  } else init.random<-NULL\n\n  if(is.null(init.theta)){\n    theta <- init_theta(model$y, model$u, model$distribution) \n  } else {\n    theta <- init.theta\n  }\n  \n \n  \n\n  if(correlating.effects){\n    likfn<-function(pars,model,estimate=TRUE){\n#       if(ndisp>0){        \n#         model$u[]<-matrix(exp(pars[1:ndisp]),n,p,byrow=TRUE)\n#       }\n      if(nr>0){\n        if(any(exp(0.5*pars[ndisp+1:nr])>1e5)) #mixing with fixed effects\n          return(.Machine$double.xmax)\n        P1<-diag(exp(0.5*pars[ndisp+1:nr]))\n        P1[upper.tri(P1)]<-pars[ndisp+nr+1:length(init.random[-(1:nr)])]\n        P1<-crossprod(P1)\n        model$P1[(nf+nc+nd+1):m,(nf+nc+nd+1):m]<-\n          as.matrix(.bdiag(replicate(p,P1,simplify=FALSE)))\n      }\n      if(nf>0){\n        Z<-matrix(0,nrow=p,ncol=nf)\n        Z[lower.tri(Z,TRUE)]<-pars[(ndisp+(nr>0)*length(init.random)+1):length(pars)]\n        model$Z[1:nf,1:p,]<-t(Z)\n      }\n      if(estimate){\n#         if(itertheta)\n#           theta <-get(\"prevtheta\",pos=env)\n        \n        res<-expfLogLikNoSim(model$y, model$Z, model$u, model$a1, model$P1, model$P1inf, \n                             1, model$tol, maxiter, maxiter2, convtol, theta, model$Zind, model$nfactors,trace,1)\n#         res$theta[res$theta>5]<-5\n#         res$theta[res$theta< -5]<- -5\n#         assign(\"prevtheta\",res$theta,pos=env)\n        if(res$conv<0){\n          warning(\"Approximating algorithm did not converge.\")\n          lik<- -.Machine$double.xmax\n          if(gradient)\n          attr(lik,\"gradient\")<-0\n        } else {\n          lik <- res$logLik\n          if(gradient)\n          attr(lik,\"gradient\")<- -res$gradient[lower.tri(res$gradient,TRUE)]\n        }\n        -lik\n      }else model\n    }\n    inits<-c(if(ndisp>0) init.dispersion else NULL, if(nr>0) init.random else NULL,\n             if(nf>0) init.factors else NULL)\n    \n  } else {\n    likfn<-function(pars,model,estimate=TRUE){      \n#       if(ndisp>0){        \n#         model$u[]<-matrix(exp(pars[1:ndisp]),n,p,byrow=TRUE)\n#       }\n      if(nr>0){\n        if(any(exp(pars[ndisp+1:nr])>1e5)) #mixing with fixed effects\n          return(.Machine$double.xmax)\n        P1<-diag(exp(pars[ndisp+1:nr]))\n        \n        model$P1[(nf+nc+nd+1):m,(nf+nc+nd+1):m]<-\n          as.matrix(.bdiag(replicate(p,P1,simplify=FALSE)))\n      }\n      if(nf>0){\n        Z<-matrix(0,nrow=p,ncol=nf)\n        Z[lower.tri(Z,TRUE)]<-pars[(ndisp+nr+1):length(pars)]\n        model$Z[1:nf,1:p,]<-t(Z)\n      }\n      if(estimate){        \n#           if(itertheta)\n#             theta <-get(\"prevtheta\",envir=env)\n#          \n        res<-expfLogLikNoSim(model$y, model$Z, model$u, model$a1, model$P1, model$P1inf, \n                             1, model$tol, maxiter, maxiter2, convtol, theta, model$Zind, model$nfactors,trace,1)\n#         res$theta[res$theta>5]<-5\n#         res$theta[res$theta< -5]<- -5\n#         assign(\"prevtheta\",res$theta,envir=env)\n        if(res$conv<0){\n          warning(\"Approximating algorithm did not converge.\")\n          lik<- -.Machine$double.xmax\n          if(gradient)\n           attr(lik,\"gradient\")<-0\n        } else {\n          lik <- res$logLik\n          if(gradient)\n            attr(lik,\"gradient\")<- -res$gradient[lower.tri(res$gradient,TRUE)]\n        }\n        -lik\n      }else model\n    }\n    inits<-c(if(ndisp>0) init.dispersion else NULL, if(nr>0) init.random else NULL,\n             if(nf>0) init.factors else NULL)  \n    \n  }\n#   env<-new.env()\n#   env$prevtheta<-theta\n  if(length(inits)>0 && estimate){\n    \n    amodel<-model         \n    dist<-pmatch(x = model$distribution, \n                 table = c(\"gaussian\", \"poisson\", \"binomial\", \n                           \"gamma\", \"negative binomial\"))    \n    true.model<-expfLogLikNoSim(model$y, model$Z, model$u, model$a1, model$P1, model$P1inf, \n                                dist, model$tol, maxiter, maxiter2, convtol, theta, model$Zind, model$nfactors,trace,0)     \n    theta<-true.model$theta\n    llold<-true.model$logLik\n    ii<-0\n    ll<-10*llold\n    while(ii<maxapp && abs(ll - llold)/(0.1 + abs(ll)) > epsilon){\n      llold<-ll\n      approx.model<-approxG(model$y, model$Z, model$u, model$a1, model$P1, model$P1inf, \n                            dist, model$tol, maxiter, maxiter2, convtol, theta, model$Zind, model$nfactors,trace)\n      theta<-approx.model$theta\n      amodel$u[]<-approx.model$H\n      amodel$y[]<-approx.model$y      \n      fit<-nlm(p=inits,f=likfn,model=amodel,estimate=TRUE,...)   \n      inits<-fit$e\n      amodel<-likfn(inits,amodel,FALSE)\n      model<-likfn(inits,model,FALSE)      \n      true.model<-expfLogLikNoSim(model$y, model$Z, model$u, model$a1, model$P1, model$P1inf, \n                      dist, model$tol, maxiter, maxiter2, convtol, theta, model$Zind, model$nfactors,trace,0)     \n      theta<-true.model$theta\n      ll<-true.model$logLik\n      ii <- ii+1\n      if(trace>0)\n        print(paste(\"ApproxMaximization iter\",ii,\"log-likelihood\",ll))\n    }    \n   \n    \n  } else{\n    model<-likfn(inits,model,FALSE)\n    fit<-\"Initial model returned.\"\n  }\n  list(model=model,fit=fit)\n}",
    "created" : 1415171946130.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3724832340",
    "id" : "5B5F5383",
    "lastKnownWriteTime" : 1415198154,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/R/fitGLMMF2.R",
    "project_path" : "R/fitGLMMF2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}