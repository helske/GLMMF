{
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n#include \"GLMMF.h\"\n// via the depends attribute we tell Rcpp to create hooks for\n// RcppArmadillo so that the build process will know what to do\n//\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// simple example of creating two matrices and\n// returning the result of an operatioon on them\n//\n// via the exports attribute we tell Rcpp to make this function\n// available from R\n\ndouble approxF(const arma::mat& y, const arma::cube& Z, const arma::mat& u, const arma::vec& a1,\nconst arma::mat& P1, const arma::mat& P1inf, const int dist, const double tol, \narma::mat&  ytilde, arma::mat& H, arma::mat& theta, const int maxiter, const int maxiter2, const double convtol, int& conv,\nconst arma::umat& zind, const int nfactors, const int trace) {\n  \n  int n = Z.n_slices;\n  int p = Z.n_cols;\n  arma::uvec ind(1);\n  \n  double ll_old;\n  double ll=0.0;\n  \n  arma::mat coefs(a1.n_elem,Z.n_slices); \n  arma::mat coefs_old(a1.n_elem,Z.n_slices);\n  arma::mat coefs_tmp(a1.n_elem,Z.n_slices);  \n  switch (dist) {\n    case 1:\n    H = u;\n    ytilde = y;\n    break;\n    case 2:\n    H = exp(-theta)/u;\n    ytilde = y%H + theta - 1.0;\n    break;\n    case 3:        \n    H = (1.0+exp(theta))%(1.0+exp(theta))/(u%exp(theta));\n    ytilde = theta + H*y - 1.0 - exp(theta);\n    break;\n    case 4:       \n    H = 1.0/u;\n    ytilde = theta+y/exp(theta)-1.0;\n    break;\n    case 5:\n    H = (1.0/u+1.0/exp(theta));\n    ytilde = theta+y/exp(theta)-1.0;\n    break;\n  }   \n  \n  ll_old = filterInApproxF(ytilde, Z, H, a1, P1, P1inf, tol,zind, nfactors, coefs);\n  for(int t = 0; t<n; t++){\n    ind =t;\n    for(int i = 0; i<p; i++){\n      theta(t,i) = arma::accu(Z.slice(t).col(i)%coefs(zind.col(i),ind));\n    }\n  }  \n  \n  if(dist > 1){\n    ll_old += scaling(dist,y,u,theta,ytilde,H);\n  } else return ll_old; //no need to iterate with gaussian model\n  \n  int iter2;\n  int iter=0;\n  while(iter < maxiter && arma::is_finite(ll)){  \n    \n    iter++;\n    conv=iter;    \n    switch (dist) {\n      case 1:\n      H = u;\n      ytilde = y;\n      break;\n      case 2:\n      H = exp(-theta)/u;\n      ytilde = y%H + theta - 1.0;\n      break;\n      case 3:        \n      H = (1.0+exp(theta))%(1.0+exp(theta))/(u%exp(theta));\n      ytilde = theta + H*y - 1.0 - exp(theta);\n      break;\n      case 4:       \n      H = 1.0/u;\n      ytilde = theta+y/exp(theta)-1.0;\n      break;\n      case 5:\n      H = (1.0/u+1.0/exp(theta));\n      ytilde = theta+y/exp(theta)-1.0;\n      break;\n    }   \n    \n    ll = filterInApproxF(ytilde, Z, H, a1, P1, P1inf, tol,zind, nfactors, coefs);\n    for(int t = 0; t<n; t++){\n      ind =t;\n      for(int i = 0; i<p; i++){\n        theta(t,i) = arma::accu(Z.slice(t).col(i)%coefs(zind.col(i),ind));\n      }\n    } \n    if(dist > 1){\n      ll += scaling(dist,y,u,theta,ytilde,H);\n    }\n    \n    if( (((ll - ll_old)/(0.1 + std::abs(ll))) <= -convtol ) && iter>1 && maxiter2>0){\n      iter2 = 0;      \n      while(((ll - ll_old)/(0.1 + std::abs(ll))) < convtol && iter2<maxiter2 && arma::is_finite(ll)){\n        iter2++;\n        if(trace>0){\n          Rcpp::Rcout<<\"Step size halved due to decreasing likelihood.\"<<std::endl;\n        }\n        \n        coefs = (coefs + coefs_old)/2.0;        \n        for(int t = 0; t<n; t++){\n          ind =t;\n          for(int i = 0; i<p; i++){\n            theta(t,i) = arma::accu(Z.slice(t).col(i)%coefs(zind.col(i),ind));\n          }\n        } \n        \n        switch (dist) {\n          case 1:\n          H = u;\n          ytilde = y;\n          break;\n          case 2:\n          H = exp(-theta)/u;\n          ytilde = y%H + theta - 1.0;\n          break;\n          case 3:        \n          H = (1.0+exp(theta))%(1.0+exp(theta))/(u%exp(theta));\n          ytilde = theta + H*y - 1.0 - exp(theta);\n          break;\n          case 4:       \n          H = 1.0/u;\n          ytilde = theta+y/exp(theta)-1.0;\n          break;\n          case 5:\n          H = (1.0/u+1.0/exp(theta));\n          ytilde = theta+y/exp(theta)-1.0;\n          break;\n        }\n        ll = filterInApproxF(ytilde, Z, H, a1, P1, P1inf, tol,zind, nfactors,coefs_tmp);    \n        for(int t = 0; t<n; t++){\n          ind =t;\n          for(int i = 0; i<p; i++){\n            theta(t,i) = arma::accu(Z.slice(t).col(i)%coefs_tmp(zind.col(i),ind));\n          }\n        } \n        if(dist > 1){\n          ll += scaling(dist,y,u,theta,ytilde,H);\n        }        \n      }\n      if(iter2==maxiter2){\n        if(trace>0){\n          Rcpp::Rcout<<\"Could not correct step size.\"<<std::endl;\n        }       \n      }      \n      coefs = coefs_tmp;\n      \n    }         \n    \n    \n    if(trace>1){\n      Rcpp::Rcout<<\"Iteration \" << iter <<\", Log-likelihood: \" << ll <<std::endl;\n    }\n    \n    \n    \n    \n    \n    if(!theta.is_finite()){\n      conv = -3;\n      break;      \n    }\n    if(std::abs(ll - ll_old)/(0.1 + std::abs(ll)) < convtol){\n      break;\n    }\n    \n    coefs_old = coefs;    \n    ll_old = ll;\n    \n  }\n  if(Rcpp::NumericMatrix::is_na(ll)){\n    if(trace>0){\n      Rcpp::Rcout << \"Non-finite log-likelihood for Gaussian approximating model.\"<<std::endl;\n    }\n    conv = -2;\n  }\n  if(iter>=maxiter){\n    if(trace>0){\n      Rcpp::Rcout << \"iteration limit reached in approximating algorithm.\"<<std::endl;\n    }\n    conv = 0;\n  }\n  \n  return ll;\n  \n}\n\n",
    "created" : 1415110718237.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3142402469",
    "id" : "F001B900",
    "lastKnownWriteTime" : 1415180342,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/src/approxF.cpp",
    "project_path" : "src/approxF.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}