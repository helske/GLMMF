{
    "contents" : "#' Fit Generalized Linear Mixed-Effects Models Using State Space Framework\n#'\n#' Function \\code{glmm} estimates GLMM using methods based on state space modelling. \n#'\n#' @export\n#' @import nloptr\n#' @import KFAS\n#' @param response.var Name of the response variable in data.\n#' @param grouping.var Name of the grouping variable in data. Only one grouping variable is allowed.\n#' @param data Optional data frame environment containing the variables in the model.\n#' @param distribution Character vector defining the distributions used for each group. \n#' Either length of one (same distribution for all groups) or length of p, number of groups. Default is \"gaussian\".\n#' @param init.random Initial values for random effect covariances.\n#' @param init.dispersion Initial values for dispersion paremeters.\n#' @param correlating.effects Logical. Default is TRUE.\n#' @param estimate.dispersion Logical. Is the dispersion parameter estimated or fixed.\n#' @param nsim Integer. Number of independent samples used in importance sampling. \n#' Default is 0, which corresponds to Laplace approximation.\n#' @param maxiter Integer. Number of iterations for in iterative weighted least squares.\n#' \n#' @examples\n#' \n#' library(lme4)\n#' fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)\n#' summary(fm1)\n#' predict(fm1) #Ennusteet mutta ei keskivirheit? tai luottamus/ennustev?lej? n?ille.\n\n#' fm1.glmm <- glmm(response.var=\"Reaction\",grouping.var=\"Subject\",REML=TRUE,\n#'                 fixed= ~Days, random= ~Days, data= sleepstudy,distribution=\"gaussian\",return.model=TRUE)\n\n# tulokset t?sm??, glmm-paketista vastaukset pit?? kaivaa v?h?n hankalammin esille (ks. names(fm1.glmm) jne.)\n\n#' fixef(fm1)\n#' fm1.glmm$fixed$coef\n#' sqrt(diag(fm1.glmm$model$P1[3:4,3:4]))\n#' cov2cor(fm1.glmm$model$P1[3:4,3:4])[1,2]\n#' VarCorr(fm1)\n#' sqrt(fm1.glmm$dispersions)\n\n#' pred<-predict(fm1.glmm$model,interval=\"prediction\",level=0.95)\n#' #piirret??n vain kolme ryhm?? ettei kuva mene ep?selv?ksi\n#' ts.plot(as.data.frame(pred)[,1:9],col=rep(1:3,each=3),lty=c(1,2,2))\n\n#' ## Poisson-malli\n#' data(butterfly)\n#' \n#' require(lme4)\n#' system.time(fit.SSglmm.reml<-glmm(response.var=\"Colias\", grouping.var=\"site\", fixed=~habitat + building + urbanveg,random=~1,\n#'                                  REML=TRUE,data=butterfly,distribution=\"poisson\",return.model=TRUE))\n#'\n#' system.time(fit.SSglmm.ml<-glmm(response.var=\"Colias\", grouping.var=\"site\", fixed=~habitat + building + urbanveg,random=~1,\n#'                                REML=FALSE,data=butterfly,distribution=\"poisson\",return.model=TRUE))\n#'\n#' fit.glmer<-glmer(Colias ~ habitat + building + urbanveg + (1|site), \n#'                 family=poisson, data=butterfly,control=glmerControl(optimizer = \"bobyqa\"))\n#'\n#' sqrt(fit.SSglmm.reml$random$P)\n#' sqrt(fit.SSglmm.ml$random$P)\n#' VarCorr(fit.glmer)\n#'\n#' fixef(fit.glmer)\n#' fit.SSglmm.ml$fixed$coef\n#' fit.SSglmm.reml$fixed$coef\n#'\n#' attr(ranef(fit.glmer, condVar = TRUE,drop=TRUE)[[1]], \"postVar\")\n#' diag(fit.SSglmm.ml$random$V)\n#' diag(fit.SSglmm.reml$random$V)\n#' \n#' require(mvabund)\n#' data(spider)\n#' x<-apply(spider$x,2,rep,times=12)\n#' dataspider<-data.frame(species=rep(names(spider$abund),each=28),abund=unlist(spider$abund),x)\n#' out<-glmm(response.var=\"abund\", grouping.var=\"species\", fixed=~soil.dry+bare.sand, random=~1, \n#' data=dataspider,distribution=\"poisson\")\n#' \n#' out2<-glmm(response.var=\"abund\", grouping.var=\"species\", fixed=~soil.dry+bare.sand,\n#' data=dataspider,distribution=\"poisson\")\n#' fit<-manyglm(mvabund(spider$abund)~soil.dry+bare.sand,data=data.frame(spider$x),family=\"poisson\")\n#' \n#' \n\nglmm<-function(response.var, grouping.var, fixed.formula, random.formula, data, distribution,\n               latent.factors=0,\n               init.random, init.factors,init.dispersion, correlating.effects=TRUE,\n               estimate.dispersion,nsim=0, return.model=TRUE,maxiter=50,maxeval=1000,xtol_rel=1e-6,estimate=TRUE,...){\n  \n  \n  #modify data\n  Y<-split(data[response.var],data[grouping.var])\n  Y<-matrix(unlist(Y,use.names=FALSE),ncol=length(Y),dimnames=list(NULL,paste0(names(Y[[1]]),\".\",names(Y))))\n  data<-split(data,data[grouping.var])\n  \n  \n  p<-ncol(Y)\n  n<-nrow(Y)\n  \n  if(missing(distribution))\n    distribution<-rep(\"gaussian\",p)  \n  \n  if(missing(init.dispersion)){\n    init.dispersion<-rep(1,p)\n  } else {\n    if(length(init.dispersion)==1){\n      init.dispersion<-rep(init.dispersion,p)\n    } else if(length(init.dispersion)!=p) stop(\"Number of initial values for dispersion parameters is not equal to number of groups.\")\n  }  \n  \n  if(missing(estimate.dispersion)) #ei j?rke? n?in, estimoi kaikki u:t...\n    estimate.dispersion<-any(distribution%in%c(\"gaussian\",\"negative binomial\",\"gamma\"))\n  \n  \n  modelformula <- formula(Y~ -1)\n  if(latent.factors>0){\n    Z<-matrix(NA,nrow=p,ncol=latent.factors,dimnames=list(NULL,paste(\"Factor\",1:latent.factors)))\n    Z[upper.tri(Z)]<-0 #is this correct?\n    modelformula<-update.formula(modelformula,.~.+\n                                   SSMcustom(Z=Z,T=diag(0,latent.factors),\n                                             R=diag(latent.factors),Q=diag(latent.factors),P1=diag(latent.factors),\n                                             P1inf=diag(0,latent.factors),a1=matrix(0,latent.factors),index=1:p,n=n))\n    if(missing(init.factors))\n      init.factors<-rep(1,sum(is.na(Z)))\n  }\n  \n  \n  # Find correct number of parameters\n  \n  if(missing(random.formula)){\n    k.fix<-p*ncol(model.matrix(fixed.formula,data=data[[1]]))\n    k.rand<-init.random<-0\n    correlating.effects<-FALSE  \n    \n    modelformula<-update.formula(modelformula,.~.+ SSMregression(rep(list(fixed.formula),p),data))     \n    \n    \n  } else {\n    \n    k.fix<-ncol(model.matrix(fixed.formula,data=data[[1]]))\n    k.rand<-ncol(model.matrix(random.formula,data=data[[1]]))\n    \n    if(k.rand<2) correlating.effects<-FALSE\n    \n    if(missing(init.random)){\n      if(correlating.effects){ \n        init.random <- diag(k.rand)[upper.tri(diag(k.rand),TRUE)] \n      }else{ \n        init.random <- rep(1, k.rand)\n      }\n    }else {\n      if(length(init.random)==1){\n        init.random<-rep(init.random,if(correlating.effects) k.rand*(k.rand+1)/2 else k.rand)\n      } else if(length(init.random)!=(if(correlating.effects) k.rand*(k.rand+1)/2 else k.rand))\n        stop(\"Incorrect number of initial values for random effect covariances.\")\n      \n    }        \n    \n    modelformula<-update.formula(modelformula,.~.+ SSMregression(rep(list(fixed.formula),p),type=\"common\",data=data)\n                                 + SSMregression(rep(list(random.formula),p),P1=diag(NA,p*k.rand),data=data))     \n    \n    \n    \n  }\n  \n\n  model<-SSModel(modelformula, distribution=distribution,u=init.dispersion,data=data)\n  \n  if((k.rand>0 || latent.factors >0 || estimate.dispersion)){ #something to estimate other than fixed effects\n  \n    if(correlating.effects){\n      likfn<-function(pars,model,estimate=TRUE,nsim=0,maxiter=50){\n        if(estimate.dispersion)\n          model$u[]<-matrix(pars[1:p],n,p,byrow=TRUE)     ##not for all!!     \n        if(k.rand>0){\n          P1<-matrix(0,k.rand,k.rand)\n          P1[upper.tri(P1,TRUE)]<-pars[estimate.dispersion*p+1:length(init.random)]\n          P1<-crossprod(P1)\n          model$P1[(k.fix+1):(k.fix+p*k.rand),(k.fix+1):(k.fix+p*k.rand)]<-\n            as.matrix(.bdiag(replicate(p,P1,simplify=FALSE)))\n        }\n        if(latent.factors>0){\n          Z<-matrix(0,nrow=p,ncol=latent.factors)\n          Z[lower.tri(Z,TRUE)]<-pars[(estimate.dispersion*p+k.rand*length(init.random)+1):length(pars)]\n          model$Z[,(ncol(model$Z)-latent.factors+1):ncol(model$Z),]<-Z\n        }\n        if(estimate){\n          -logLik(model,nsim=nsim,maxiter=maxiter)  \n        }else model\n      }\n      inits<-c(if(estimate.dispersion) init.dispersion else NULL, if(k.rand>0) init.random else NULL,\n               if(latent.factors>0) init.factors else NULL)\n      tmp<-diag(k.rand)\n      lower<-c(rep(0,(estimate.dispersion)*p),               \n                 ifelse(tmp[upper.tri(tmp,TRUE)]==0,-Inf,0),\n               rep(-Inf,length(init.factors)))\n      \n      if(estimate)\n      fit<-nloptr(eval_f=likfn,x0=inits,lb=lower,model=model,estimate=TRUE,\n                  nsim=nsim,maxiter=maxiter,opts=list(algorithm=\"NLOPT_LN_BOBYQA\",maxeval=maxeval,xtol_rel=xtol_rel,...))      \n      \n    } else {\n      likfn<-function(pars,model,estimate=TRUE,nsim=0,maxiter=50){\n        if(estimate.dispersion)\n          model$u[]<-matrix(pars[1:p],n,p,byrow=TRUE)\n        if(k.rand>0)\n          diag(model$P1)[(k.fix+1):(length(model$a1))]<-pars[estimate.dispersion*p+1:k.rand]  \n        if(latent.factors>0){\n          Z<-matrix(0,nrow=p,ncol=latent.factors)\n          Z[lower.tri(Z,TRUE)]<-pars[(estimate.dispersion*p+k.rand*length(init.random)+1):length(pars)]\n          model$Z[,(ncol(model$Z)-latent.factors+1):ncol(model$Z),]<-Z\n          \n        }\n        if(estimate){\n          -logLik(model,nsim=nsim,maxiter=maxiter)  \n        }else model\n      }\n      inits<-c(if(estimate.dispersion) init.dispersion else NULL, if(k.rand>0) init.random else NULL,\n               if(latent.factors>0) init.factors else NULL)\n      \n      lower<-c(rep(0,(estimate.dispersion)*p+k.rand),               \n               rep(-Inf,length(init.factors)))\n      if(estimate)\n      fit<-nloptr(eval_f=likfn,x0=inits,lb=lower,model=model,estimate=TRUE,\n                  nsim=nsim,maxiter=maxiter,opts=list(algorithm=\"NLOPT_LN_BOBYQA\",maxeval=maxeval,xtol_rel=xtol_rel,...))       \n      \n    }\n    \n    if(estimate){\n    model<-likfn(fit$solution,model,FALSE)  \n    if(fit$status!=1)\n      warning(fit$message) \n    } else model<-likfn(inits,model,FALSE)\n    \n    \n  }\n  \n \n  \n  \n  kfs.out<-KFS(model,smoothing=c(\"state\",\"mean\"),nsim=nsim,maxiter=maxiter)  \n  \n  \n  ll<-logLik(model,nsim=nsim,maxiter=maxiter)\n  \n  results<-list(fixed=list(coef=coef(kfs.out,1,1)[1:k.fix],V_fixed=kfs.out$V[1:k.fix,1:k.fix,1]),\n                random=if(k.rand>0) list(effects=coef(kfs.out,1,1)[-(1:k.fix)],V_random=kfs.out$V[-(1:k.fix),-(1:k.fix),1],\n                                         P=model$P1[(k.fix+1):(k.fix+k.rand),(k.fix+1):(k.fix+k.rand)]) else NULL,\n                factors=if(latent.factors>0) list(gamma=model$Z[,(ncol(model$Z)-latent.factors+1):ncol(model$Z),1],\n                                                  u=coef(kfs.out)[,(ncol(model$Z)-latent.factors+1):ncol(model$Z)],\n                                                  V=kfs.out$V[(ncol(model$Z)-latent.factors+1):ncol(model$Z),\n                                                                (ncol(model$Z)-latent.factors+1):ncol(model$Z),]) else NULL,\n                fitted=list(fitted=kfs.out$mu,V=kfs.out$V_muhat),\n                dispersions=model$u[1,],logLik=ll,\n                call= match.call(expand.dots = FALSE), model=if(return.model) model else NULL)\n  class(results)<-\"glmm.results\"\n  results\n}",
    "created" : 1415110432831.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2789424930",
    "id" : "ED7A7A39",
    "lastKnownWriteTime" : 1414410183,
    "path" : "U:/MyPrograms/gitrepos/StateSpaceGLMM/R/glmm.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}