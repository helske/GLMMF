{
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n#include \"GLMMF.h\"\n// via the depends attribute we tell Rcpp to create hooks for\n// RcppArmadillo so that the build process will know what to do\n//\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// simple example of creating two matrices and\n// returning the result of an operatioon on them\n//\n// via the exports attribute we tell Rcpp to make this function\n// available from R\n// [[Rcpp::export]]\n\nRcpp::List expfLogLikNoSim(const Rcpp::NumericMatrix y_, const Rcpp::NumericVector Z_, const Rcpp::NumericMatrix u_,\nconst Rcpp::NumericVector a1_, const Rcpp::NumericMatrix P1_, const Rcpp::NumericMatrix P1inf_, \nconst int dist, double tol, int maxiter, int maxiter2, double convtol, Rcpp::NumericMatrix theta_\n, const Rcpp::IntegerMatrix Zind_, const int nfactors, const int trace,const int compgrad){\n  \n  const unsigned int n = y_.nrow();\n  const unsigned int p = y_.ncol();\n  const unsigned int m = P1_.nrow();\n  const unsigned int m1 = Zind_.nrow();\n  \n  const arma::mat y(y_.begin(), n,p, false);\n  const arma::cube Z(Z_.begin(), m1, p, n, false);\n  const arma::mat u(u_.begin(), n,p, false);\n  const arma::vec a1(a1_.begin(),m, false);\n  const arma::mat P1(P1_.begin(),m,m, false);\n  const arma::mat P1inf(P1inf_.begin(),m,m, false);\n  \n  const arma::imat izind(Zind_.begin(),m1,p,false);\n  const arma::umat zind = arma::conv_to<arma::umat>::from(izind);\n  \n  arma::mat theta(theta_.begin(), n,p, true);\n  arma::mat ytilde(n,p);\n  arma::mat H(n,p);\n  \n  double loglik; \n  double gloglik;\n  int conv = 0; \n  if(dist>1){\n    // approximating Gaussian model \n    if(nfactors>0){\n      loglik = approxF(y, Z, u, a1, P1, P1inf, dist, tol, ytilde, H, theta, maxiter, maxiter2, convtol, \n      conv, zind, nfactors,trace);   \n    } else {  \n      loglik = approxNF(y, Z, u, a1, P1, P1inf, dist, tol, ytilde, H, theta, maxiter, maxiter2, convtol, \n      conv, zind, trace);\n    }\n    if(conv<0){\n      return Rcpp::List::create(Rcpp::Named(\"logLik\") = -std::numeric_limits<double>::max(), Rcpp::Named(\"convergence\") = conv);\n    }  \n  } else {\n    ytilde = y;\n    H = u;    \n  }\n  arma::mat grad(p,nfactors);\n  grad.zeros();\n  if(compgrad==1 && nfactors>0){\n    arma::mat coefs(m,n);\n    arma::cube coefVars(m,m,n); \n    arma::rowvec tmpm(m);\n    arma::rowvec tmpm2(m);\n    if(nfactors>0){\n      gloglik = smootherF(ytilde, Z, H, a1, P1, P1inf, tol,zind, nfactors,coefs,coefVars);\n    } else {\n      gloglik = smootherNF(ytilde, Z, H, a1, P1, P1inf, tol,zind,coefs,coefVars);\n    }\n    switch (dist) {     \n      case 1:\n      loglik = gloglik;\n      for(int j=0; j<p; j++){\n        for(int k=0; k<nfactors; k++){\n          if(j>=k){\n            for(int t=0; t<n; t++){\n              tmpm = coefVars.slice(t).row(k);\n              tmpm2 = coefs.col(t).t();\n              \n              grad(j,k) += (ytilde(t,j)*coefs(k,t)-\n              arma::as_scalar((tmpm.cols(zind.col(j)) + coefs(k,t)*tmpm2.cols(zind.col(j)))*Z.slice(t).col(j)))/H(t,j);              \n            }\n          }\n        }\n      }\n      break;\n      case 2:\n      // Not correct!!\n      for(int j=0; j<p; j++){\n        for(int k=0; k<nfactors; k++){\n          if(j>=k){\n            for(int t=0; t<n; t++){\n              grad(j,k) += (y(t,j)-exp(theta(t,j)))*coefs(k,t);              \n            }\n          }\n        }\n      }\n      break;\n    }\n  }\n  \n  \n  \n  return Rcpp::List::create(Rcpp::Named(\"theta\") = theta, Rcpp::Named(\"gradient\") = grad,\n  Rcpp::Named(\"logLik\") = loglik,Rcpp::Named(\"convergence\") = conv);\n}\n",
    "created" : 1414689099401.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1111737227",
    "id" : "CA77D861",
    "lastKnownWriteTime" : 1415210603,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/src/expfLogLikNoSim.cpp",
    "project_path" : "src/expfLogLikNoSim.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}