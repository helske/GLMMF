{
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n#include \"GLMMF.h\"\n// via the depends attribute we tell Rcpp to create hooks for\n// RcppArmadillo so that the build process will know what to do\n//\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// simple example of creating two matrices and\n// returning the result of an operatioon on them\n//\n// via the exports attribute we tell Rcpp to make this function\n// available from R\n\ndouble smootherF(const arma::mat& y, const arma::cube& Z, const arma::mat& H,\nconst arma::colvec& a1, const arma::mat& P1, const arma::mat& P1inf, const double tol,\nconst arma::umat& zind, const int nfactors, arma::mat& coefs,arma::cube& coefVars) {\n  \n  \n  double tiny = std::numeric_limits<double>::min();\n  \n  int n = Z.n_slices;\n  int p = Z.n_cols;\n  unsigned int m = P1.n_rows;\n  unsigned int m1 = Z.n_rows;  \n  int j=0;\n  int d=-1;\n  arma::vec at(a1.begin(),m);           // m\n  //at = a1;\n  \n  arma::mat vt(p,n);            // p x n\n  \n  arma::mat pt(P1.begin(),m,m); // m x m\n  arma::cube kt(m,p,n); // m x p x n\n  arma::mat ft(p,n);            // p x n\n  \n  \n  arma::mat pinf(P1inf.begin(),m,m); // m x m\n  arma::cube kinf(m,p,n); // m x p x n\n  arma::mat finf(p,n);            // p x n\n  \n  arma::cube PinfAll(m,m,n);\n  \n  coefs.col(0)=a1;\n  PinfAll.slice(0) = P1inf; \n  coefVars.slice(0) = P1;   \n  \n  int rankp = arma::accu(P1inf);\n  \n  double lik = 0.0;\n  const double c = 0.5*std::log(2.0*M_PI);\n  \n  double finv;\n  arma::vec tmpm(m);\n  \n  \n  kt.zeros();\n  kinf.zeros();\n  kt.slice(0).col(0) = pt.cols(zind.col(0))*Z.slice(0).col(0);    \n  \n  double yhat = arma::accu(Z.slice(0).col(0)%at.rows(zind.col(0)));\n  tmpm = kt.slice(0).col(0);\n  double zk = arma::accu(Z.slice(0).col(0)%tmpm.rows(zind.col(0)));  \n  \n  if(rankp>0){\n    \n    kinf.slice(0).col(0) = pinf.cols(zind.col(0))*Z.slice(0).col(0); \n    tmpm = kinf.slice(0).col(0);\n    finf(0,0) = arma::accu(Z.slice(0).col(0)%tmpm.rows(zind.col(0)));  \n    while(d < n && rankp>0){   \n      d++;\n      for(j=0; j<p; j++){\n        if(arma::is_finite(y(d,j))){\n          ft(j,d) = zk + H(d,j);\n          if(finf(j,d)>tol){\n            finv = 1.0/finf(j,d);\n            lik += 0.5*log(finv);\n            vt(j,d) = y(d,j)-yhat;\n            at = at + kinf.slice(d).col(j)*vt(j,d)*finv;             \n            //pinf = pinf - kinf*kinf.t()*finf;\n            //pt = pt +(kinf*kinf.t()*ft*finf-kt*kinf.t()-kinf*kt.t())*finf; \n            for(unsigned int k = 0; k<m; k++){\n              for(unsigned int l = k; l<m; l++){                \n                pinf(l,k) = pinf(l,k) - kinf(l,j,d)*kinf(k,j,d)*finv; \n                pt(l,k) = pt(l,k) +kinf(l,j,d)*kinf(k,j,d)*pow(finv,2)*ft(j,d)-\n                kt(l,j,d)*kinf(k,j,d)*finv-kinf(l,j,d)*kt(k,j,d)*finv;\n              }\n            }\n            //pt = symmatl(pt);\n            //pinf = symmatl(pinf);  \n            \n            rankp--;\n          } else {\n            if (ft(j,d) > tiny){\n              finv=1.0/ft(j,d);\n              vt(j,d) = y(d,j)-yhat;\n              lik -= c + 0.5*(-log(finv) + pow(vt(j,d),2)*finv);\n              at = at + kt.slice(d).col(j)*vt(j,d)*finv;\n              //pt = pt - kt*kt.t()*ft; \n              for(unsigned int k = 0; k<m; k++){\n                for(unsigned int l = k; l<m; l++){\n                  pt(l,k) = pt(l,k) - kt(l,j,d)*kt(k,j,d)*finv;         \n                }\n              }\n              //pt = symmatl(pt); \n            }\n          }\n        }\n        //        \n        if(j==(p-1)){\n          //next time step\n          if(d<(n-1)){\n            \n            pt.submat(nfactors,0,m-1,nfactors-1).zeros();\n            // pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n            pt.submat(0,0,nfactors-1,nfactors-1).eye();\n            //            pinf.submat(nfactors,0,m-1,nfactors-1).zeros();\n            //            pinf.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n            //            pinf.submat(0,0,nfactors-1,nfactors-1).eye();\n            at.subvec(0,nfactors-1).zeros();\n            coefs.col(d+1) = at;\n            coefVars.slice(d+1) = pt;\n            PinfAll.slice(d+1) = pinf;\n            //Rcpp::Rcout<<atf.col(d)<<std::endl; //upper triangular part is not referenced!!\n            //Rcpp::Rcout<<pt<<std::endl;\n            \n            //kt =     pt.cols(zind.col(0))*Z.slice(d+1).col(0);   \n            //kinf = pinf.cols(zind.col(0))*Z.slice(d+1).col(0);\n            for(unsigned int k = 0; k<m; k++){\n              for(unsigned int l = 0; l<m1; l++){\n                kt(k,0,d+1) = kt(k,0,d+1) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n              }\n            }  \n            for(unsigned int k = 0; k<m; k++){\n              for(unsigned int l = 0; l<m1; l++){\n                kinf(k,0,d+1) = kinf(k,0,d+1) + pinf(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n              }\n            }  \n            yhat = arma::accu(Z.slice(d+1).col(0)%at.rows(zind.col(0)));\n            tmpm = kt.slice(d+1).col(0);\n            zk = arma::accu(Z.slice(d+1).col(0)%tmpm.rows(zind.col(0)));     \n            tmpm = kinf.slice(d+1).col(0);\n            finf(0,d+1) = arma::accu(Z.slice(d+1).col(0)%tmpm.rows(zind.col(0)));\n            \n          }\n        } else {\n          \n          //next observation\n          //kt =  pt.cols(zind.col(j+1))*Z.slice(d).col(j+1);\n          //kinf = pinf.cols(zind.col(j+1))*Z.slice(d).col(j+1);\n          \n          for(unsigned int k = 0; k<m; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k,j+1,d) = kt(k,j+1,d) + pt(std::max(k,zind(l,j+1)), std::min(k,zind(l,j+1))) * Z(l,j+1,d);       \n            }\n          }\n          for(unsigned int k = 0; k<m; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kinf(k,j+1,d) = kinf(k,j+1,d) + pinf(std::max(k,zind(l,j+1)), std::min(k,zind(l,j+1))) * Z(l,j+1,d);       \n            }\n          }\n          yhat = arma::accu(Z.slice(d).col(j+1)%at.rows(zind.col(j+1)));\n          tmpm = kt.slice(d).col(j+1);\n          zk = arma::accu(Z.slice(d).col(j+1)%tmpm.rows(zind.col(j+1)));\n          tmpm = kinf.slice(d).col(j+1);\n          finf(j+1,d) = arma::accu(Z.slice(d).col(j+1)%tmpm.rows(zind.col(j+1)));\n        }\n        if(rankp==0){\n          // d--; // negate the last increment below \n          break;\n        }\n      }\n      \n    }\n    for(int i = j+1; i<p; i++){\n      \n      if(arma::is_finite(y(d,i))){\n        ft(i,d) = zk + H(d,i);\n        \n        if (ft(i,d) > tiny){\n          finv = 1.0/ft(i,d);\n          vt(i,d) = y(d,i)-yhat;\n          lik -= c + 0.5*(-log(finv) + pow(vt(i,d),2)*finv);\n          at = at + kt.slice(d).col(i)*vt(i,d)*finv;\n          for(unsigned int k = 0; k<m; k++){\n            for(unsigned int l = k; l<m; l++){\n              pt(l,k) = pt(l,k) - kt(l,i,d)*kt(k,i,d)*finv;          \n            }\n          }\n          //pt = symmatl(pt);         \n        }\n      }\n      if(i==(p-1)){\n        //next time step         \n        if(d<(n-1)){\n          \n          \n          pt.submat(nfactors,0,m-1,nfactors-1).zeros();\n          // pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n          pt.submat(0,0,nfactors-1,nfactors-1).eye();\n          at.subvec(0,nfactors-1).zeros();\n          coefs.col(d+1)=at;\n          coefVars.slice(d+1) = pt;\n          //kt = pt.cols(zind.col(0))*Z.slice(d+1).col(0);   \n          for(unsigned int k = 0; k<m; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k,0,d+1) = kt(k,0,d+1) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n            }\n          }   \n          yhat = arma::accu(Z.slice(d+1).col(0)%at.rows(zind.col(0)));\n          tmpm = kt.slice(d+1).col(0);\n          zk = arma::accu(Z.slice(d+1).col(0)%tmpm.rows(zind.col(0)));         \n        }\n      } else {\n        //next observation\n        // kt = pt.cols(zind.col(i+1))*Z.slice(d).col(i+1);      \n        for(unsigned int k = 0; k<m; k++){\n          for(unsigned int l = 0; l<m1; l++){\n            kt(k,i+1,d) = kt(k,i+1,d) + pt(std::max(k,zind(l,i+1)), std::min(k,zind(l,i+1))) * Z(l,i+1,d);       \n          }\n        }\n        yhat = arma::accu(Z.slice(d).col(i+1)%at.rows(zind.col(i+1)));\n        tmpm = kt.slice(d).col(i+1);\n        zk = arma::accu(Z.slice(d).col(i+1)%tmpm.rows(zind.col(i+1))); \n        \n      }\n      \n      \n    }\n    // d++;\n  }    \n  \n  \n  for(int t = d+1; t<n; t++){   \n    for(int i = 0; i<p; i++){\n      if(arma::is_finite(y(t,i))){\n        ft(i,t) = zk + H(t,i);\n        \n        if (ft(i,t) > tiny){\n          finv = 1.0/ft(i,t);\n          vt(i,t) = y(t,i)-yhat;\n          lik -= c + 0.5*(-log(finv) + pow(vt(i,t),2)*finv);\n          at = at + kt.slice(t).col(i)*vt(i,t)*finv;\n          for(unsigned int k = 0; k<m; k++){\n            for(unsigned int l = k; l<m; l++){\n              pt(l,k) = pt(l,k) - kt(l,i,t)*kt(k,i,t)*finv;          \n            }\n          }         \n        }\n      }\n      \n      if(i==(p-1)){\n        //next time step\n        if(t<(n-1)){  \n          \n          pt.submat(nfactors,0,m-1,nfactors-1).zeros();\n          pt.submat(0,0,nfactors-1,nfactors-1).eye();\n          at.subvec(0,nfactors-1).zeros();\n          coefs.col(t+1)=at;\n          coefVars.slice(t+1) = pt;\n          for(unsigned int k = 0; k<m; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k,0,t+1) = kt(k,0,t+1) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,t+1);       \n            }\n          }        \n          yhat = arma::accu(Z.slice(t+1).col(0)%at.rows(zind.col(0)));\n          tmpm = kt.slice(t+1).col(0);\n          zk = arma::accu(Z.slice(t+1).col(0)%tmpm.rows(zind.col(0)));         \n        }\n      } else {\n        //next observation      \n        for(unsigned int k = 0; k<m; k++){\n          for(unsigned int l = 0; l<m1; l++){\n            kt(k,i+1,t) = kt(k,i+1,t) + pt(std::max(k,zind(l,i+1)), std::min(k,zind(l,i+1))) * Z(l,i+1,t);       \n          }\n        }  \n        yhat = arma::accu(Z.slice(t).col(i+1)%at.rows(zind.col(i+1)));\n        \n        tmpm = kt.slice(t).col(i+1);\n        zk = arma::accu(Z.slice(t).col(i+1)%tmpm.rows(zind.col(i+1))); \n        \n      }        \n      \n    } \n  }\n  \n  arma::vec rt(m,arma::fill::zeros);  \n  arma::mat Nt(m,m,arma::fill::zeros);  \n  arma::mat L0(m,m);\n  //arma::mat diagm = arma::eye<arma::mat>(m,m);\n  \n  //This could be optimized by using symmetry!!!!\n  //and using sparsity of Z?\n  \n  for(int t=(n-1); t>d; t--){\n    for(int i=(p-1); i>=0; i--){\n      if(arma::is_finite(y(t,i)) && ft(i,t)>tiny){\n        L0.eye();\n        L0.cols(zind.col(i)) -= kt.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);\n        \n        rt = L0.t()*rt;  \n        rt(zind.col(i)) += Z.slice(t).col(i)*vt(i,t)/ft(i,t);\n        \n        Nt = L0.t()*Nt*L0;\n        Nt.submat(zind.col(i),zind.col(i)) += Z.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);\n        \n        \n        \n      }//identical(t((k[,2,drop=FALSE]%*%z[2,c(1,2,5,6),drop=FALSE]))%*%r,(t((k[,2,drop=FALSE]%*%z[2,,drop=FALSE]))%*%r)[c(1,2,5,6),,drop=FALSE])\n    }\n    coefVars.slice(t) = symmatl(coefVars.slice(t));\n    coefs.col(t) = coefs.col(t) + coefVars.slice(t)*rt;\n    coefVars.slice(t) = coefVars.slice(t) - coefVars.slice(t)*Nt*coefVars.slice(t);\n    if(t>0 && nfactors<m){\n      rt.rows(0,nfactors-1).zeros();\n      Nt.submat(0,0,nfactors-1,nfactors-1).zeros();\n    }\n  }\n  \n  arma::vec rt0(m,arma::fill::zeros);\n  arma::vec rt1(m,arma::fill::zeros);\n  \n  arma::mat Linf(m,m);\n  arma::mat Nt0(m,m,arma::fill::zeros);\n  arma::mat Nt1(m,m,arma::fill::zeros);\n  arma::mat Nt2(m,m,arma::fill::zeros); \n  \n  if(d>=0){  \n    int t=d;   \n    \n    for(int i=(p-1);i>j;i--){         \n      \n      if(arma::is_finite(y(t,i)) && ft(i,t)>tiny){         \n        L0.eye();\n        L0.cols(zind.col(i)) -= kt.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);\n        \n        rt = L0.t()*rt;\n        rt(zind.col(i)) += Z.slice(t).col(i)*vt(i,t)/ft(i,t);\n        \n        Nt = L0.t()*Nt*L0;\n        Nt.submat(zind.col(i),zind.col(i)) += Z.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);\n        \n        \n      }\n    }\n    rt0 = rt;\n    Nt0 = Nt;\n    \n    for(int i=j;i>=0; i--){\n      if(arma::is_finite(y(t,i))){\n        if(finf(i,t)>tol){\n          Linf.eye();\n          Linf.cols(zind.col(i)) -= kinf.slice(t).col(i)*Z.slice(t).col(i).t()/finf(i,t);\n          \n          L0.zeros();\n          L0.cols(zind.col(i)) = (ft(i,t)/finf(i,t)*kinf.slice(t).col(i)-kt.slice(t).col(i))*Z.slice(t).col(i).t()/finf(i,t);      \n          \n          rt1 = L0.t()*rt0 + Linf.t()*rt1; \n          rt1(zind.col(i)) += Z.slice(t).col(i)*vt(i,t)/finf(i,t);         \n          \n          rt0 = Linf.t()*rt0;            \n          \n          Nt2 = L0.t()*Nt0*L0 + Linf.t()*Nt1*L0 + L0.t()*Nt1.t()*Linf +\n          Linf.t()*Nt2*Linf;\n          Nt2.submat(zind.col(i),zind.col(i)) -= Z.slice(t).col(i)*Z.slice(t).col(i).t()*ft(i,t)/pow(finf(i,t),2);             \n          \n          Nt1 =  L0.t()*Nt0*Linf + Linf.t()*Nt1*Linf;\n          Nt1.submat(zind.col(i),zind.col(i)) += Z.slice(t).col(i)*Z.slice(t).col(i).t()/finf(i,t); \n          \n          Nt0 = Linf.t()*Nt0*Linf;\n          \n        } else {\n          if(ft(i,t)>tiny){\n            L0.eye();\n            L0.cols(zind.col(i)) -= kt.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);        \n            \n            rt0 = L0.t()*rt0;\n            rt(zind.col(i)) += Z.slice(t).col(i)*vt(i,t)/ft(i,t);\n            \n            rt1 = L0.t()*rt1;\n            \n            Nt0 = L0.t()*Nt0*L0;\n            Nt0.submat(zind.col(i),zind.col(i)) += Z.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);\n            \n            Nt1 = Nt1*L0;\n            Nt2 = Nt2*L0;\n          }\n        }        \n      }   \n    }\n    coefVars.slice(t) = symmatl(coefVars.slice(t));\n    PinfAll.slice(t) = symmatl(PinfAll.slice(t));\n    \n    coefs.col(t) = coefs.col(t) + coefVars.slice(t)*rt0 + PinfAll.slice(t)*rt1;    \n    \n    coefVars.slice(t) = coefVars.slice(t) - coefVars.slice(t)*Nt0*coefVars.slice(t)-PinfAll.slice(t)*Nt1*coefVars.slice(t)\n    - coefVars.slice(t)*Nt1.t()*PinfAll.slice(t) - PinfAll.slice(t)*Nt2*PinfAll.slice(t);\n    \n    if(t>0 && nfactors<m){\n      rt0.rows(0,nfactors-1).zeros();\n      rt1.rows(0,nfactors-1).zeros();\n      Nt0.submat(0,0,nfactors-1,nfactors-1).zeros();\n      Nt1.submat(0,0,nfactors-1,nfactors-1).zeros();\n      Nt2.submat(0,0,nfactors-1,nfactors-1).zeros();\n      \n    }\n    \n    for(int t=(d-1);t>=0;t--){\n      for(int i=(p-1);i>=0;i--){\n        if(arma::is_finite(y(t,i))){\n          if(finf(i,t)>tol){\n            Linf.eye();\n            Linf.cols(zind.col(i)) -= kinf.slice(t).col(i)*Z.slice(t).col(i).t()/finf(i,t);\n            \n            L0.zeros();\n            L0.cols(zind.col(i)) = (ft(i,t)/finf(i,t)*kinf.slice(t).col(i)-kt.slice(t).col(i))*Z.slice(t).col(i).t()/finf(i,t);      \n            \n            rt1 = L0.t()*rt0 + Linf.t()*rt1; \n            rt1(zind.col(i)) += Z.slice(t).col(i)*vt(i,t)/finf(i,t);         \n            \n            rt0 = Linf.t()*rt0;            \n            \n            Nt2 = L0.t()*Nt0*L0 + Linf.t()*Nt1*L0 + L0.t()*Nt1.t()*Linf +\n            Linf.t()*Nt2*Linf;\n            Nt2.submat(zind.col(i),zind.col(i)) -= Z.slice(t).col(i)*Z.slice(t).col(i).t()*ft(i,t)/pow(finf(i,t),2);             \n            \n            Nt1 =  L0.t()*Nt0*Linf + Linf.t()*Nt1*Linf;\n            Nt1.submat(zind.col(i),zind.col(i)) += Z.slice(t).col(i)*Z.slice(t).col(i).t()/finf(i,t); \n            \n            Nt0 = Linf.t()*Nt0*Linf;\n            \n          } else {\n            if(ft(i,t)>tiny){\n              L0.eye();\n              L0.cols(zind.col(i)) -= kt.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);        \n              \n              rt0 = L0.t()*rt0;\n              rt(zind.col(i)) += Z.slice(t).col(i)*vt(i,t)/ft(i,t);\n              \n              rt1 = L0.t()*rt1;\n              \n              Nt0 = L0.t()*Nt0*L0;\n              Nt0.submat(zind.col(i),zind.col(i)) += Z.slice(t).col(i)*Z.slice(t).col(i).t()/ft(i,t);\n              \n              Nt1 = Nt1*L0;\n              Nt2 = Nt2*L0;\n            }\n          }        \n        }   \n      }\n      coefVars.slice(t) = symmatl(coefVars.slice(t));\n      PinfAll.slice(t) = symmatl(PinfAll.slice(t));\n      \n      coefs.col(t) = coefs.col(t) + coefVars.slice(t)*rt0 + PinfAll.slice(t)*rt1;    \n      \n      coefVars.slice(t) = coefVars.slice(t) - coefVars.slice(t)*Nt0*coefVars.slice(t)-PinfAll.slice(t)*Nt1*coefVars.slice(t)\n      - coefVars.slice(t)*Nt1.t()*PinfAll.slice(t) - PinfAll.slice(t)*Nt2*PinfAll.slice(t);\n      if(t>0 && nfactors<m){\n        rt0.rows(0,nfactors-1).zeros();\n        rt1.rows(0,nfactors-1).zeros();\n        Nt0.submat(0,0,nfactors-1,nfactors-1).zeros();\n        Nt1.submat(0,0,nfactors-1,nfactors-1).zeros();\n        Nt2.submat(0,0,nfactors-1,nfactors-1).zeros();\n        \n      }\n    }\n  }\n  //Lazy solution (uses symmatl):\n  \n  \n  \n//  for(int t=0; t<=d; t++){     \n//    coefVars.slice(t) = symmatl(coefVars.slice(t));\n//    PinfAll.slice(t) = symmatl(PinfAll.slice(t));\n//    \n//    coefs.col(t) = coefs.col(t) + coefVars.slice(t)*rt0.col(t) + PinfAll.slice(t)*rt1.col(t);    \n//    \n//    coefVars.slice(t) = coefVars.slice(t) - coefVars.slice(t)*Nt0.slice(t)*coefVars.slice(t)-PinfAll.slice(t)*Nt1.slice(t)*coefVars.slice(t)\n//    - coefVars.slice(t)*Nt1.slice(t).t()*PinfAll.slice(t) - PinfAll.slice(t)*Nt2.slice(t)*PinfAll.slice(t);\n//  }\n//  for(int t=d+1; t<n;t++){\n//    coefVars.slice(t) = symmatl(coefVars.slice(t));\n//    coefs.col(t) = coefs.col(t) + coefVars.slice(t)*rt.col(t);\n//    coefVars.slice(t) = coefVars.slice(t) - coefVars.slice(t)*Nt.slice(t)*coefVars.slice(t);\n//  }   \n  \n  return lik;\n  \n}",
    "created" : 1415212016053.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "339968833",
    "id" : "BEC0D07E",
    "lastKnownWriteTime" : 1415212107,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/src/smootherF.cpp",
    "project_path" : "src/smootherF.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}