{
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n#include \"ssglmInternals.h\"\n// via the depends attribute we tell Rcpp to create hooks for\n// RcppArmadillo so that the build process will know what to do\n//\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// simple example of creating two matrices and\n// returning the result of an operatioon on them\n//\n// via the exports attribute we tell Rcpp to make this function\n// available from R\n\ndouble approxInternal(const arma::mat& y, const arma::cube& Z, const arma::mat& u, const arma::vec& a1,\nconst arma::mat& P1, const arma::mat& P1inf, const Rcpp::IntegerVector& dist, const double tol, \narma::mat&  ytilde, arma::mat& H, arma::mat& theta, const int maxiter, const double convtol, int& conv,\nconst arma::umat& zind, const int nfactors) {\n  \n    \n  int iter=0;\n  double diff=1000.0;\n  double ll_old= -std::numeric_limits<double>::max();\n  double dev=0.0;\n  double ll=0.0;\n  \n  while(arma::is_finite(diff) && diff > convtol && iter < maxiter){    \n    iter++;\n    conv=iter;    \n    \n    for(int i = 0; i<dist.size(); i++){      \n      switch (dist(i)) {\n        case 1:\n        H.col(i) = u.col(i);\n        ytilde.col(i) = y.col(i);\n        break;\n        case 2:\n        H.col(i) = exp(-theta.col(i))/u.col(i);\n        ytilde.col(i) = y.col(i)%H.col(i) + theta.col(i) - 1.0;\n        break;\n        case 3:        \n        H.col(i) = (1.0+exp(theta.col(i)))%(1.0+exp(theta.col(i)))/(u.col(i)%exp(theta.col(i)));\n        ytilde.col(i) = theta.col(i) + H.col(i)*y.col(i) - 1.0 - exp(theta.col(i));\n        break;\n        case 4:\n        \n        H.col(i) = 1.0/u.col(i);\n        ytilde.col(i) = theta.col(i)+y.col(i)/exp(theta.col(i))-1.0;\n        break;\n        case 5:\n        H.col(i) = (1.0/u.col(i)+1.0/exp(theta.col(i)));\n        ytilde.col(i) = theta.col(i)+y.col(i)/exp(theta.col(i))-1.0;\n        break;\n      }\n    }\n    \n    if(arma::accu(arma::find_finite(y)!=arma::find_finite(ytilde)) || !H.is_finite()){\n      conv = -3;\n      break;      \n    }\n    \n    if(nfactors==0){\n      ll = filterInternal(ytilde, Z, H, a1, P1, P1inf, tol, theta, zind);  \n    } else {      \n      ll = filterFInternal(ytilde, Z, H, a1, P1, P1inf, tol, theta, zind, nfactors);  \n    }    \n    \n    for(unsigned int i=0; i<dist.size(); i++){\n      if(dist(i) > 1){        \n        ll += scaling(dist(i),y.col(i),u.col(i),theta.col(i),ytilde.col(i),H.col(i));\n      }\n    }    \n   \n    diff = std::abs(ll - ll_old)/(0.1 + std::abs(ll));\n    \n    if(diff > convtol && ll < ll_old){\n    Rcpp::Rcout << \"IRLS did not converge.\"<<std::endl;\n    Rcpp::Rcout<<\"Iteration: \" << iter<<std::endl;\n    Rcpp::Rcout << \"Difference ll_old - ll_new \"<< ll_old - ll <<std::endl;\n    conv = -1;\n    break;\n    }        \n    ll_old = ll;        \n    \n  }\n  if(Rcpp::NumericMatrix::is_na(diff)){\n    Rcpp::Rcout << \"Non-finite log-likelihood for Gaussian approximating model.\"<<std::endl;\n    conv = -2;\n  }\n  if(iter>=maxiter){\n    Rcpp::Rcout << \"iteration limit reached in approximating algorithm.\"<<std::endl;\n    conv = 0;\n  }\n \n  return ll;\n  \n}",
    "created" : 1413876601875.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3936755739",
    "id" : "53DAB0CA",
    "lastKnownWriteTime" : 1414137109,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/src/approxInternal.cpp",
    "project_path" : "src/approxInternal.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}