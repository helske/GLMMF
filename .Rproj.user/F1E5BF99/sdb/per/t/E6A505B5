{
    "contents" : "fitGLMMF<-function(model,estimate.dispersion,correlating.effects,maxiter,convtol,\n                   init.random.cov,init.dispersion,init.factor,common.dispersion,estimate,...){\n  \n  \n  #for more compact likfn  \n  nr<-model$nrandom\n  nf<-model$nfactors\n  nc<-model$ncommon\n  nd<-model$ndistinct\n  n<-nrow(model$y)\n  p<-ncol(model$y)\n  m<-nrow(model$P1)\n  \n  if(missing(estimate.dispersion) || estimate.dispersion){\n    if(model$distribution%in%c(\"gaussian\",\"negative binomial\",\"gamma\")){\n      ndisp<-ifelse(common.dispersion,1,p)\n    } else ndisp<-0\n  } else ndisp<-0\n  \n  if(nr<2) correlating.effects<-FALSE\n  \n  if(nf>0){\n    if(missing(init.factor)){\n      init.factors<-rep(1,p*nf-sum(upper.tri(diag(nf))))\n    } else {\n      if(!identical(dim(init.factor),c(p,as.integer(nf)))){\n        stop(\"Dimensions of the initial latent factor matrix is not equal to p*nfactors.\")\n      }\n      init.factors<-init.factor[lower.tri(init.factor,TRUE)]\n    }  \n  } else init.factors<-NULL\n  \n  if(ndisp>0){\n    if(missing(init.dispersion)){\n      init.dispersion<-rep(1,ndisp)\n    } else {\n      if(length(init.dispersion)==1){\n        init.dispersion<-rep(log(init.dispersion),ndisp)\n      } else {\n        if(length(init.dispersion)!=ndisp) \n          stop(\"Number of initial values for distinct dispersion parameters is not equal to groups\")\n        init.dispersion<-log(init.dispersion)\n      }\n    }  \n  }\n  \n  if(nr>0){\n    if(missing(init.random.cov)){\n      if(correlating.effects){ \n        init.random <- diag(nr)[upper.tri(diag(nr),TRUE)] \n      }else{ \n        init.random <- rep(1, nr)\n      }\n    }else {\n      if(!identical(dim(init.random.cov),c(nr,nr)))\n        stop(\"Dimensions of the initial covariance matrix of random effects does not match with number of random effects.\")\n      \n      if(correlating.effects){\n        init.random.cov<-VarCorr(fm1)$Subject\n        tmp<-chol(init.random.cov)\n        init.random<-c(2*log(diag(tmp)),tmp[upper.tri(tmp)])  \n      } else init.random<-sqrt(init.random.cov[1 + 0:(nr - 1) * (nr + 1)])\n    }\n  } else init.random<-NULL\n  theta <- KFAS:::init_theta(model$y, model$u, rep(model$distribution,p)) \n  \n  dist<-rep(pmatch(x = model$distribution, \n                   table = c(\"gaussian\", \"poisson\", \"binomial\", \n                             \"gamma\", \"negative binomial\")),p)\n  \n  if(correlating.effects){\n    likfn<-function(pars,model,estimate=TRUE){\n      if(ndisp>0){        \n        model$u[]<-matrix(exp(pars[1:ndisp]),n,p,byrow=TRUE)\n      }\n      if(nr>0){\n        if(any(exp(0.5*pars[ndisp+1:nr])>1e5)) #mixing with fixed effects\n          return(.Machine$double.xmax)\n        P1<-diag(exp(0.5*pars[ndisp+1:nr]))\n        P1[upper.tri(P1)]<-pars[ndisp+nr+1:length(init.random[-(1:nr)])]\n        P1<-crossprod(P1)\n        model$P1[(nf+nc+nd+1):m,(nf+nc+nd+1):m]<-\n          as.matrix(.bdiag(replicate(p,P1,simplify=FALSE)))\n      }\n      if(nf>0){\n        Z<-matrix(0,nrow=p,ncol=nf)\n        Z[lower.tri(Z,TRUE)]<-pars[(ndisp+(nr>0)*length(init.random)+1):length(pars)]\n        model$Z[1:nf,1:p,]<-t(Z)\n      }\n      if(estimate){\n        if(ndisp>0)\n          theta <- KFAS:::init_theta(model$y, model$u, rep(model$distribution,p)) \n        res<-expfLogLikNoSim(model$y, model$Z, model$u, model$a1, model$P1, model$P1inf, \n                             dist, model$tol, maxiter, convtol, theta, model$Zind, model$nfactors)\n        \n        if(res$conv%in%(1:2)){\n          warning(\"Approximating algorithm did not converge.\")\n          lik<- .Machine$double.xmax\n        } else lik <- -res$logLik\n        lik\n      }else model\n    }\n    inits<-c(if(ndisp>0) init.dispersion else NULL, if(nr>0) init.random else NULL,\n             if(nf>0) init.factors else NULL)\n    \n  } else {\n    likfn<-function(pars,model,estimate=TRUE){      \n      if(ndisp>0){        \n        model$u[]<-matrix(exp(pars[1:ndisp]),n,p,byrow=TRUE)\n      }\n      if(nr>0){\n        if(any(exp(pars[ndisp+1:nr])>1e5)) #mixing with fixed effects\n          return(.Machine$double.xmax)\n        P1<-diag(exp(pars[ndisp+1:nr]))\n        \n        model$P1[(nf+nc+nd+1):m,(nf+nc+nd+1):m]<-\n          as.matrix(.bdiag(replicate(p,P1,simplify=FALSE)))\n      }\n      if(nf>0){\n        Z<-matrix(0,nrow=p,ncol=nf)\n        Z[lower.tri(Z,TRUE)]<-pars[(ndisp+nr+1):length(pars)]\n        model$Z[1:nf,1:p,]<-t(Z)\n      }\n      if(estimate){\n        if(ndisp>0)\n          theta <- KFAS:::init_theta(model$y, model$u, rep(model$distribution,p)) \n        res<-expfLogLikNoSim(model$y, model$Z, model$u, model$a1, model$P1, model$P1inf, \n                             dist, model$tol, maxiter, convtol, theta, model$Zind, model$nfactors)\n        if(res$conv<0){\n          warning(\"Approximating algorithm did not converge.\")\n          lik<- .Machine$double.xmax                  \n        } else lik <- -res$logLik\n        lik\n      }else model\n    }\n    inits<-c(if(ndisp>0) init.dispersion else NULL, if(nr>0) init.random else NULL,\n             if(nf>0) init.factors else NULL)  \n    \n  }\n  \n  if(length(inits)>0 && estimate){\n    fit<-optim(par=inits,fn=likfn,model=model,...)\n    model<-likfn(fit$p,model,FALSE) \n    #if(fit$convergence!=0)\n    #  warning(fit$message) \n  } else{\n    model<-likfn(inits,model,FALSE)\n    fit<-\"Initial model returned.\"\n  }\n  list(model=model,fit=fit)\n}",
    "created" : 1413809524397.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3564538951",
    "id" : "E6A505B5",
    "lastKnownWriteTime" : 1414137682,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/R/fitGLMMF.R",
    "project_path" : "R/fitGLMMF.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}