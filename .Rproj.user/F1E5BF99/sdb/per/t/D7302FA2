{
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n#include \"ssglmInternals.h\"\n// via the depends attribute we tell Rcpp to create hooks for\n// RcppArmadillo so that the build process will know what to do\n//\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// simple example of creating two matrices and\n// returning the result of an operatioon on them\n//\n// via the exports attribute we tell Rcpp to make this function\n// available from R\n\ndouble deviance(const arma::mat& y, const arma::mat& u, \nconst Rcpp::IntegerVector& dist, const arma::mat& theta) {\n  \n  \n  // This function is not optimized at all!!!\n  \n  const unsigned int n = y.n_rows;\n  const unsigned int p = y.n_cols; \n  arma::mat res(n,p);  \n  arma::mat mu(n,p);\n  arma::vec tmp(n);\n  arma::vec tmp2(n);\n  \n            \n  res = y;\n  \n  for(int i = 0; i<dist.size(); i++){      \n    switch (dist(i)) {\n      case 1:\n      res.col(i) = arma::pow(res.col(i)-theta.col(i),2);      \n      break;\n      case 2:\n      mu.col(i) =  exp(theta.col(i))%u.col(i);    \n     \n \n      tmp = res.col(i)/mu.col(i);\n      tmp.elem(find(res.col(i) == 0.0) ).ones();\n      res.col(i) =  2.0*(res.col(i)%log(tmp) - res.col(i) + mu.col(i));      \n      \n//      // from glm:  good <- (weights > 0) & (mu.eta.val != 0)\n//Rcpp::Rcout<<res.col(i)<<std::endl;\n//      tmp = res.col(i);      \n//      tmp.elem(find(mu.col(i)<1e-12)).zeros();\n//      res.col(i) = tmp;\n     \n      break;\n      case 3:        \n      mu.col(i) = exp(theta.col(i))/(1.0+exp(theta.col(i)));\n      \n      res.col(i) = res.col(i)/u.col(i);\n      tmp = res.col(i)/mu.col(i);\n      tmp.elem(find(res.col(i) == 0.0) ).ones();                \n      \n      tmp2 = (1.0 - res.col(i))/(1 - mu.col(i));\n      tmp2.elem(find(res.col(i) == 1.0) ).ones(); \n      tmp2.elem(find(mu.col(i) == 1.0) ).ones();                \n      res.col(i) = 2.0 * u.col(i) % (res.col(i) % log(tmp) + (1.0 - \n      res.col(i)) % log(tmp2));\n      break;\n      case 4:\n      mu.col(i) = exp(theta.col(i));\n      \n      tmp = res.col(i)/mu.col(i);\n      tmp.elem(find(res.col(i) == 0.0) ).ones();\n      \n      res.col(i) = -2.0 * (log(tmp) - (res.col(i)-mu.col(i))/mu.col(i));      \n      \n      break;\n      case 5:\n      mu.col(i) = exp(theta.col(i));\n      \n      tmp = res.col(i)/mu.col(i);\n      for(unsigned int j=1;j<n;j++){\n        if(res(j,i)<1.0){\n          tmp(j,i) = 1.0/mu(j,i);\n        }\n      }\n      \n      res.col(i) = 2.0 * (res.col(i)%log(tmp) - \n      (res.col(i)+u.col(i))%log((res.col(i)+u.col(i))/(mu.col(i)+u.col(i))));\n      break;\n    }\n  }  \n  return arma::accu( res.elem( find_finite(res) ) );\n  \n  \n}",
    "created" : 1413887422590.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1017035418",
    "id" : "D7302FA2",
    "lastKnownWriteTime" : 1414096336,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/src/deviance.cpp",
    "project_path" : "src/deviance.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}