{
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n// we only include RcppArmadillo.h which pulls Rcpp.h in for us\n#include \"ssglmInternals.h\"\n// via the depends attribute we tell Rcpp to create hooks for\n// RcppArmadillo so that the build process will know what to do\n//\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// simple example of creating two matrices and\n// returning the result of an operatioon on them\n//\n// via the exports attribute we tell Rcpp to make this function\n// available from R\n\nvoid filter(const arma::mat& y, const arma::cube& Z, const arma::mat& H,\nconst arma::colvec& a1, const arma::mat& P1, const arma::mat& P1inf, const double tol,\nconst arma::umat& zind, const int nfactors, arma::mat& coefs,arma::cube& coefVars) {\n  \n  \n  double tiny = std::numeric_limits<double>::min();\n  \n  arma::mat pt(P1.begin(),P1.n_rows,P1.n_rows);  \n  arma::vec at(a1.begin(),P1.n_rows);\n  arma::vec kt(pt.n_rows);\n  \n  \n  unsigned int m1 = Z.n_rows;\n  \n  double vt, ft;\n  unsigned int j=0;\n  unsigned int d=0;\n  int rankp = arma::accu(P1inf);\n  \n  double lik = 0.0;\n  const double c = 0.5*std::log(2.0*M_PI);\n  \n  kt = pt.cols(zind.col(0))*Z.slice(0).col(0);  \n  double yhat = arma::accu(Z.slice(0).col(0)%at.rows(zind.col(0)));\n  double zk = arma::accu(Z.slice(0).col(0)%kt.rows(zind.col(0)));\n  \n  \n  \n  if(rankp>0){\n    \n    arma::vec kinf(pt.n_rows);\n    arma::mat pinf(P1inf.begin(),pt.n_rows,pt.n_rows);\n    double finf;\n    \n    kinf = pinf.cols(zind.col(0))*Z.slice(0).col(0);   \n    finf = arma::accu(Z.slice(0).col(0)%kinf.rows(zind.col(0)));  \n    while(d < Z.n_slices && rankp>0){   \n      \n      for(j=0; j<Z.n_cols; j++){\n        if(arma::is_finite(y(d,j))){\n          ft = zk + H(d,j);\n          if(finf>tol){\n            finf = 1.0/finf;\n            lik += 0.5*log(finf);\n            vt = y(d,j)-yhat;\n            at = at + kinf*vt*finf;     \n            //pinf = pinf - kinf*kinf.t()*finf;\n            //pt = pt +(kinf*kinf.t()*ft*finf-kt*kinf.t()-kinf*kt.t())*finf; \n            for(unsigned int k = 0; k<pinf.n_rows; k++){\n              for(unsigned int l = k; l<pinf.n_rows; l++){                \n                pinf(l,k) = pinf(l,k) - kinf(l)*kinf(k)*finf; \n                pt(l,k) = pt(l,k) +kinf(l)*kinf(k)*pow(finf,2)*ft-\n                kt(l)*kinf(k)*finf-kinf(l)*kt(k)*finf;\n              }\n            }\n            //pt = symmatl(pt);\n            //pinf = symmatl(pinf);  \n            \n            rankp--;\n          } else {\n            if (ft > tiny){\n              ft=1.0/ft;\n              vt = y(d,j)-yhat;\n              lik -= c + 0.5*(-log(ft) + pow(vt,2)*ft);\n              at = at + kt*vt*ft;\n              //pt = pt - kt*kt.t()*ft; \n              for(unsigned int k = 0; k<pt.n_rows; k++){\n                for(unsigned int l = k; l<pt.n_rows; l++){\n                  pt(l,k) = pt(l,k) - kt(l)*kt(k)*ft;          \n                }\n              }\n              //pt = symmatl(pt); \n            }\n          }\n        }\n        if(j==(Z.n_cols-1)){\n          //next time step\n          coefs.col(d)=at;\n          coefVars.slice(d)=pt;\n          if(nfactors> 0){     \n            pt.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n            pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n            pt.submat(0,0,nfactors-1,nfactors-1).eye();   \n            pinf.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n            pinf.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n            pinf.submat(0,0,nfactors-1,nfactors-1).eye();\n            at.subvec(0,nfactors-1).zeros();\n          }\n          if(d<(Z.n_slices-1)){\n            //kt =     pt.cols(zind.col(0))*Z.slice(d+1).col(0);   \n            //kinf = pinf.cols(zind.col(0))*Z.slice(d+1).col(0);\n            kt.zeros();\n            for(unsigned int k = 0; k<pt.n_rows; k++){\n              for(unsigned int l = 0; l<m1; l++){\n                kt(k) = kt(k) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n              }\n            }  \n            kinf.zeros();\n            for(unsigned int k = 0; k<pt.n_rows; k++){\n              for(unsigned int l = 0; l<m1; l++){\n                kinf(k) = kinf(k) + pinf(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n              }\n            }  \n            yhat = arma::accu(Z.slice(d+1).col(0)%at.rows(zind.col(0)));\n            zk = arma::accu(Z.slice(d+1).col(0)%kt.rows(zind.col(0)));          \n            finf = arma::accu(Z.slice(d+1).col(0)%kinf.rows(zind.col(0)));  \n          }\n        } else {\n          //next observation\n          //kt =  pt.cols(zind.col(j+1))*Z.slice(d).col(j+1);\n          //kinf = pinf.cols(zind.col(j+1))*Z.slice(d).col(j+1);\n          kt.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k) = kt(k) + pt(std::max(k,zind(l,j+1)), std::min(k,zind(l,j+1))) * Z(l,j+1,d);       \n            }\n          }\n          kinf.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kinf(k) = kinf(k) + pinf(std::max(k,zind(l,j+1)), std::min(k,zind(l,j+1))) * Z(l,j+1,d);       \n            }\n          }\n          yhat = arma::accu(Z.slice(d).col(j+1)%at.rows(zind.col(j+1)));\n          zk = arma::accu(Z.slice(d).col(j+1)%kt.rows(zind.col(j+1))); \n          finf = arma::accu(Z.slice(d).col(j+1)%kinf.rows(zind.col(j+1)));\n          \n        }\n        if(rankp==0){\n          d--; // negate the last increment below \n          break;\n        }\n        \n      }\n      d++;\n    }\n    \n    for(unsigned int i = j+1; i<Z.n_cols; i++){\n      \n      if(arma::is_finite(y(d,i))){\n        ft = zk + H(d,i);\n        \n        if (ft > tiny){\n          ft = 1.0/ft;\n          vt = y(d,i)-yhat;\n          lik -= c + 0.5*(-log(ft) + pow(vt,2)*ft);\n          at = at + kt*vt*ft;\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = k; l<pt.n_rows; l++){\n              pt(l,k) = pt(l,k) - kt(l)*kt(k)*ft;          \n            }\n          }\n          //pt = symmatl(pt);         \n        }\n      }\n      \n      if(i==(Z.n_cols-1)){\n        //next time step\n        coefs.col(d)=at;\n        coefVars.slice(d)=pt;\n        if(nfactors> 0){\n          pt.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n          pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n          pt.submat(0,0,nfactors-1,nfactors-1).eye();\n          at.subvec(0,nfactors-1).zeros();\n        }\n        if(d<(Z.n_slices-1)){\n          \n          //kt = pt.cols(zind.col(0))*Z.slice(d+1).col(0);     \n          kt.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k) = kt(k) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,d+1);       \n            }\n          }   \n          yhat = arma::accu(Z.slice(d+1).col(0)%at.rows(zind.col(0)));\n          zk = arma::accu(Z.slice(d+1).col(0)%kt.rows(zind.col(0)));         \n        }\n      } else {\n        //next observation\n        // kt = pt.cols(zind.col(i+1))*Z.slice(d).col(i+1);      \n        kt.zeros();\n        for(unsigned int k = 0; k<pt.n_rows; k++){\n          for(unsigned int l = 0; l<m1; l++){\n            kt(k) = kt(k) + pt(std::max(k,zind(l,i+1)), std::min(k,zind(l,i+1))) * Z(l,i+1,d);       \n          }\n        }\n        yhat = arma::accu(Z.slice(d).col(i+1)%at.rows(zind.col(i+1)));\n        zk = arma::accu(Z.slice(d).col(i+1)%kt.rows(zind.col(i+1))); \n        \n      }\n      \n      \n    }\n    d++;\n  }    \n  \n  \n  \n  for(unsigned int t = d; t<Z.n_slices; t++){   \n    for(unsigned int i = 0; i<Z.n_cols; i++){\n      if(arma::is_finite(y(t,i))){\n        ft = zk + H(t,i);\n        \n        if (ft > tiny){\n          ft = 1.0/ft;\n          vt = y(t,i)-yhat;\n          lik -= c + 0.5*(-log(ft) + pow(vt,2)*ft);\n          at = at + kt*vt*ft;\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = k; l<pt.n_rows; l++){\n              pt(l,k) = pt(l,k) - kt(l)*kt(k)*ft;          \n            }\n          }         \n        }\n      }\n      if(i==(Z.n_cols-1)){\n        //next time step\n        coefs.col(t)=at;\n        coefVars.slice(t)=pt;\n        if(nfactors> 0){\n          pt.submat(nfactors,0,pt.n_rows-1,nfactors-1).zeros();\n          pt.submat(0,nfactors,nfactors-1,pt.n_cols-1).zeros();\n          pt.submat(0,0,nfactors-1,nfactors-1).eye();\n          at.subvec(0,nfactors-1).zeros();\n        }\n        if(t<(Z.n_slices-1)){  \n          kt.zeros();\n          for(unsigned int k = 0; k<pt.n_rows; k++){\n            for(unsigned int l = 0; l<m1; l++){\n              kt(k) = kt(k) + pt(std::max(k,zind(l,0)),std::min(k,zind(l,0)))*Z(l,0,t+1);       \n            }\n          }        \n          yhat = arma::accu(Z.slice(t+1).col(0)%at.rows(zind.col(0)));\n          zk = arma::accu(Z.slice(t+1).col(0)%kt.rows(zind.col(0)));         \n        }\n      } else {\n        //next observation      \n        kt.zeros();\n        for(unsigned int k = 0; k<pt.n_rows; k++){\n          for(unsigned int l = 0; l<m1; l++){\n            kt(k) = kt(k) + pt(std::max(k,zind(l,i+1)), std::min(k,zind(l,i+1))) * Z(l,i+1,t);       \n          }\n        }  \n        yhat = arma::accu(Z.slice(t).col(i+1)%at.rows(zind.col(i+1)));\n        zk = arma::accu(Z.slice(t).col(i+1)%kt.rows(zind.col(i+1))); \n        \n      }        \n      \n    } \n  }\n  \n  \n}",
    "created" : 1413810761301.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3733972684",
    "id" : "28EB56C5",
    "lastKnownWriteTime" : 1413876297,
    "path" : "U:/MyPrograms/gitrepos/GLMMF/src/filter.cpp",
    "project_path" : "src/filter.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}